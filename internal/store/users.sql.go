// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE lower(email) = lower($1) AND id != $2) AS exists
`

type CheckEmailExistsParams struct {
	Email string
	ID    int64
}

func (q *Queries) CheckEmailExists(ctx context.Context, arg CheckEmailExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkEmailExists, arg.Email, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const clearPasswordResetTokenHash = `-- name: ClearPasswordResetTokenHash :exec
UPDATE users
SET password_reset_token_hash = NULL,
    password_reset_token_created_at = NULL,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) ClearPasswordResetTokenHash(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, clearPasswordResetTokenHash, id)
	return err
}

const confirmUserEmail = `-- name: ConfirmUserEmail :exec
UPDATE users
SET email = COALESCE(unconfirmed_email, email),
    email_confirmed_at = now(),
    unconfirmed_email = NULL,
    email_confirmation_token_hash = NULL,
    email_confirmation_token_created_at = NULL,
    updated_at = now()
WHERE id = $1
`

func (q *Queries) ConfirmUserEmail(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, confirmUserEmail, id)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_digest, inviter_id, campaign)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, username, email
`

type CreateUserParams struct {
	Username       string
	Email          string
	PasswordDigest string
	InviterID      pgtype.Int8
	Campaign       string
}

type CreateUserRow struct {
	ID       int64
	Username string
	Email    string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordDigest,
		arg.InviterID,
		arg.Campaign,
	)
	var i CreateUserRow
	err := row.Scan(&i.ID, &i.Username, &i.Email)
	return i, err
}

const getPublicProfile = `-- name: GetPublicProfile :one
SELECT
    u.username,
    u.about,
    u.website,
    u.is_moderator,
    u.created_at,
    (SELECT count(*) FROM stories s WHERE s.user_id = u.id AND s.deleted_at IS NULL)::bigint AS story_count,
    inviter.username AS inviter_name
FROM users u
LEFT JOIN users inviter ON inviter.id = u.inviter_id
WHERE lower(u.username) = lower($1)
  AND u.banned_at IS NULL
  AND u.deleted_at IS NULL
LIMIT 1
`

type GetPublicProfileRow struct {
	Username    string
	About       string
	Website     string
	IsModerator bool
	CreatedAt   pgtype.Timestamptz
	StoryCount  int64
	InviterName pgtype.Text
}

func (q *Queries) GetPublicProfile(ctx context.Context, username string) (GetPublicProfileRow, error) {
	row := q.db.QueryRow(ctx, getPublicProfile, username)
	var i GetPublicProfileRow
	err := row.Scan(
		&i.Username,
		&i.About,
		&i.Website,
		&i.IsModerator,
		&i.CreatedAt,
		&i.StoryCount,
		&i.InviterName,
	)
	return i, err
}

const getUserByEmailConfirmationTokenHash = `-- name: GetUserByEmailConfirmationTokenHash :one
SELECT id, username, email, password_digest, is_moderator, banned_at, deleted_at, inviter_id, campaign, password_reset_token_hash, password_reset_token_created_at, email_confirmed_at, email_confirmation_token_hash, email_confirmation_token_created_at, unconfirmed_email, website, about, created_at, updated_at
FROM users
WHERE email_confirmation_token_hash = $1
  AND email_confirmation_token_created_at > now() - INTERVAL '24 hours'
LIMIT 1
`

func (q *Queries) GetUserByEmailConfirmationTokenHash(ctx context.Context, emailConfirmationTokenHash pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailConfirmationTokenHash, emailConfirmationTokenHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordDigest,
		&i.IsModerator,
		&i.BannedAt,
		&i.DeletedAt,
		&i.InviterID,
		&i.Campaign,
		&i.PasswordResetTokenHash,
		&i.PasswordResetTokenCreatedAt,
		&i.EmailConfirmedAt,
		&i.EmailConfirmationTokenHash,
		&i.EmailConfirmationTokenCreatedAt,
		&i.UnconfirmedEmail,
		&i.Website,
		&i.About,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_digest, is_moderator, banned_at, deleted_at, inviter_id, campaign, password_reset_token_hash, password_reset_token_created_at, email_confirmed_at, email_confirmation_token_hash, email_confirmation_token_created_at, unconfirmed_email, website, about, created_at, updated_at
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordDigest,
		&i.IsModerator,
		&i.BannedAt,
		&i.DeletedAt,
		&i.InviterID,
		&i.Campaign,
		&i.PasswordResetTokenHash,
		&i.PasswordResetTokenCreatedAt,
		&i.EmailConfirmedAt,
		&i.EmailConfirmationTokenHash,
		&i.EmailConfirmationTokenCreatedAt,
		&i.UnconfirmedEmail,
		&i.Website,
		&i.About,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByLogin = `-- name: GetUserByLogin :one
SELECT id, username, email, password_digest, is_moderator, banned_at, deleted_at, inviter_id, campaign, password_reset_token_hash, password_reset_token_created_at, email_confirmed_at, email_confirmation_token_hash, email_confirmation_token_created_at, unconfirmed_email, website, about, created_at, updated_at
FROM users
WHERE (lower(email) = lower($1) AND email_confirmed_at IS NOT NULL)
   OR lower(username) = lower($1)
ORDER BY (lower(username) = lower($1)) DESC
LIMIT 1
`

func (q *Queries) GetUserByLogin(ctx context.Context, login string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByLogin, login)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordDigest,
		&i.IsModerator,
		&i.BannedAt,
		&i.DeletedAt,
		&i.InviterID,
		&i.Campaign,
		&i.PasswordResetTokenHash,
		&i.PasswordResetTokenCreatedAt,
		&i.EmailConfirmedAt,
		&i.EmailConfirmationTokenHash,
		&i.EmailConfirmationTokenCreatedAt,
		&i.UnconfirmedEmail,
		&i.Website,
		&i.About,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPasswordResetTokenHash = `-- name: GetUserByPasswordResetTokenHash :one
SELECT id, username, email, password_digest, is_moderator, banned_at, deleted_at, inviter_id, campaign, password_reset_token_hash, password_reset_token_created_at, email_confirmed_at, email_confirmation_token_hash, email_confirmation_token_created_at, unconfirmed_email, website, about, created_at, updated_at
FROM users
WHERE password_reset_token_hash = $1
  AND password_reset_token_created_at > now() - INTERVAL '24 hours'
LIMIT 1
`

func (q *Queries) GetUserByPasswordResetTokenHash(ctx context.Context, passwordResetTokenHash pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPasswordResetTokenHash, passwordResetTokenHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordDigest,
		&i.IsModerator,
		&i.BannedAt,
		&i.DeletedAt,
		&i.InviterID,
		&i.Campaign,
		&i.PasswordResetTokenHash,
		&i.PasswordResetTokenCreatedAt,
		&i.EmailConfirmedAt,
		&i.EmailConfirmationTokenHash,
		&i.EmailConfirmationTokenCreatedAt,
		&i.UnconfirmedEmail,
		&i.Website,
		&i.About,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setEmailChangeConfirmationToken = `-- name: SetEmailChangeConfirmationToken :exec
UPDATE users
SET email_confirmation_token_hash = $1,
    email_confirmation_token_created_at = now(),
    unconfirmed_email = $2,
    updated_at = now()
WHERE id = $3
`

type SetEmailChangeConfirmationTokenParams struct {
	EmailConfirmationTokenHash pgtype.Text
	UnconfirmedEmail           pgtype.Text
	ID                         int64
}

func (q *Queries) SetEmailChangeConfirmationToken(ctx context.Context, arg SetEmailChangeConfirmationTokenParams) error {
	_, err := q.db.Exec(ctx, setEmailChangeConfirmationToken, arg.EmailConfirmationTokenHash, arg.UnconfirmedEmail, arg.ID)
	return err
}

const setEmailConfirmationToken = `-- name: SetEmailConfirmationToken :exec
UPDATE users
SET email_confirmation_token_hash = $1,
    email_confirmation_token_created_at = now(),
    updated_at = now()
WHERE id = $2
`

type SetEmailConfirmationTokenParams struct {
	EmailConfirmationTokenHash pgtype.Text
	ID                         int64
}

func (q *Queries) SetEmailConfirmationToken(ctx context.Context, arg SetEmailConfirmationTokenParams) error {
	_, err := q.db.Exec(ctx, setEmailConfirmationToken, arg.EmailConfirmationTokenHash, arg.ID)
	return err
}

const setPasswordResetTokenHash = `-- name: SetPasswordResetTokenHash :exec
UPDATE users
SET password_reset_token_hash = $1,
    password_reset_token_created_at = now(),
    updated_at = now()
WHERE id = $2
`

type SetPasswordResetTokenHashParams struct {
	PasswordResetTokenHash pgtype.Text
	ID                     int64
}

func (q *Queries) SetPasswordResetTokenHash(ctx context.Context, arg SetPasswordResetTokenHashParams) error {
	_, err := q.db.Exec(ctx, setPasswordResetTokenHash, arg.PasswordResetTokenHash, arg.ID)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users
SET email = $1, updated_at = now()
WHERE id = $2
`

type UpdateUserEmailParams struct {
	Email string
	ID    int64
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserEmail, arg.Email, arg.ID)
	return err
}

const updateUserPasswordByID = `-- name: UpdateUserPasswordByID :exec
UPDATE users
SET password_digest = $1, updated_at = now()
WHERE id = $2
`

type UpdateUserPasswordByIDParams struct {
	PasswordDigest string
	ID             int64
}

func (q *Queries) UpdateUserPasswordByID(ctx context.Context, arg UpdateUserPasswordByIDParams) error {
	_, err := q.db.Exec(ctx, updateUserPasswordByID, arg.PasswordDigest, arg.ID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE users
SET website = $1, about = $2, updated_at = now()
WHERE id = $3
`

type UpdateUserProfileParams struct {
	Website string
	About   string
	ID      int64
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile, arg.Website, arg.About, arg.ID)
	return err
}
