// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: votes.sql

package store

import (
	"context"
)

const createVote = `-- name: CreateVote :one
WITH ins AS (
    INSERT INTO votes (user_id, story_id)
    VALUES ($2, $1)
    ON CONFLICT DO NOTHING
    RETURNING story_id
)
UPDATE stories SET upvotes = upvotes + (SELECT count(*) FROM ins)::int
WHERE id = $1
RETURNING upvotes
`

type CreateVoteParams struct {
	StoryID int64
	UserID  int64
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) (int32, error) {
	row := q.db.QueryRow(ctx, createVote, arg.StoryID, arg.UserID)
	var upvotes int32
	err := row.Scan(&upvotes)
	return upvotes, err
}

const deleteVote = `-- name: DeleteVote :one
WITH del AS (
    DELETE FROM votes
    WHERE votes.user_id = $2 AND votes.story_id = $1
    RETURNING story_id
)
UPDATE stories SET upvotes = upvotes - (SELECT count(*) FROM del)::int
WHERE id = $1
RETURNING upvotes
`

type DeleteVoteParams struct {
	StoryID int64
	UserID  int64
}

func (q *Queries) DeleteVote(ctx context.Context, arg DeleteVoteParams) (int32, error) {
	row := q.db.QueryRow(ctx, deleteVote, arg.StoryID, arg.UserID)
	var upvotes int32
	err := row.Scan(&upvotes)
	return upvotes, err
}

const getUserVotes = `-- name: GetUserVotes :many
SELECT story_id
FROM votes
WHERE user_id = $1 AND story_id = ANY($2::bigint[])
`

type GetUserVotesParams struct {
	UserID   int64
	StoryIds []int64
}

func (q *Queries) GetUserVotes(ctx context.Context, arg GetUserVotesParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUserVotes, arg.UserID, arg.StoryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var story_id int64
		if err := rows.Scan(&story_id); err != nil {
			return nil, err
		}
		items = append(items, story_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
