// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stories.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStories = `-- name: CountStories :one
SELECT count(*) FROM stories WHERE deleted_at IS NULL
`

func (q *Queries) CountStories(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countStories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStory = `-- name: CreateStory :one
INSERT INTO stories (user_id, domain_id, origin_id, url, normalized_url, title, body, short_code)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, domain_id, origin_id, url, normalized_url, title, body, short_code, created_at, updated_at, deleted_at
`

type CreateStoryParams struct {
	UserID        int64
	DomainID      pgtype.Int8
	OriginID      pgtype.Int8
	Url           pgtype.Text
	NormalizedUrl pgtype.Text
	Title         string
	Body          pgtype.Text
	ShortCode     string
}

type CreateStoryRow struct {
	ID            int64
	UserID        int64
	DomainID      pgtype.Int8
	OriginID      pgtype.Int8
	Url           pgtype.Text
	NormalizedUrl pgtype.Text
	Title         string
	Body          pgtype.Text
	ShortCode     string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
}

func (q *Queries) CreateStory(ctx context.Context, arg CreateStoryParams) (CreateStoryRow, error) {
	row := q.db.QueryRow(ctx, createStory,
		arg.UserID,
		arg.DomainID,
		arg.OriginID,
		arg.Url,
		arg.NormalizedUrl,
		arg.Title,
		arg.Body,
		arg.ShortCode,
	)
	var i CreateStoryRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DomainID,
		&i.OriginID,
		&i.Url,
		&i.NormalizedUrl,
		&i.Title,
		&i.Body,
		&i.ShortCode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createTagging = `-- name: CreateTagging :exec
INSERT INTO taggings (story_id, tag_id)
VALUES ($1, $2)
`

type CreateTaggingParams struct {
	StoryID int64
	TagID   int64
}

func (q *Queries) CreateTagging(ctx context.Context, arg CreateTaggingParams) error {
	_, err := q.db.Exec(ctx, createTagging, arg.StoryID, arg.TagID)
	return err
}

const deleteTaggingsByStory = `-- name: DeleteTaggingsByStory :exec
DELETE FROM taggings WHERE story_id = $1
`

func (q *Queries) DeleteTaggingsByStory(ctx context.Context, storyID int64) error {
	_, err := q.db.Exec(ctx, deleteTaggingsByStory, storyID)
	return err
}

const findRecentByNormalizedURL = `-- name: FindRecentByNormalizedURL :one
SELECT id, url, title, short_code, created_at
FROM stories
WHERE normalized_url = $1
  AND deleted_at IS NULL
  AND created_at > now() - INTERVAL '30 days'
ORDER BY created_at DESC
LIMIT 1
`

type FindRecentByNormalizedURLRow struct {
	ID        int64
	Url       pgtype.Text
	Title     string
	ShortCode string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) FindRecentByNormalizedURL(ctx context.Context, normalizedUrl pgtype.Text) (FindRecentByNormalizedURLRow, error) {
	row := q.db.QueryRow(ctx, findRecentByNormalizedURL, normalizedUrl)
	var i FindRecentByNormalizedURLRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.ShortCode,
		&i.CreatedAt,
	)
	return i, err
}

const getStoryByID = `-- name: GetStoryByID :one
SELECT
    s.id,
    s.user_id,
    s.url,
    s.title,
    s.body,
    s.short_code,
    s.upvotes,
    s.downvotes,
    s.comment_count,
    s.created_at,
    u.username,
    d.domain,
    o.origin
FROM stories AS s
JOIN users AS u ON u.id = s.user_id
LEFT JOIN domains AS d ON d.id = s.domain_id
LEFT JOIN origins AS o ON o.id = s.origin_id
WHERE s.id = $1 AND s.deleted_at IS NULL
`

type GetStoryByIDRow struct {
	ID           int64
	UserID       int64
	Url          pgtype.Text
	Title        string
	Body         pgtype.Text
	ShortCode    string
	Upvotes      int32
	Downvotes    int32
	CommentCount int32
	CreatedAt    pgtype.Timestamptz
	Username     string
	Domain       pgtype.Text
	Origin       pgtype.Text
}

func (q *Queries) GetStoryByID(ctx context.Context, id int64) (GetStoryByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoryByID, id)
	var i GetStoryByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.Body,
		&i.ShortCode,
		&i.Upvotes,
		&i.Downvotes,
		&i.CommentCount,
		&i.CreatedAt,
		&i.Username,
		&i.Domain,
		&i.Origin,
	)
	return i, err
}

const getStoryByShortCode = `-- name: GetStoryByShortCode :one
SELECT
    s.id,
    s.user_id,
    s.url,
    s.title,
    s.body,
    s.short_code,
    s.upvotes,
    s.downvotes,
    s.comment_count,
    s.created_at,
    u.username,
    d.domain,
    o.origin
FROM stories AS s
JOIN users AS u ON u.id = s.user_id
LEFT JOIN domains AS d ON d.id = s.domain_id
LEFT JOIN origins AS o ON o.id = s.origin_id
WHERE s.short_code = $1 AND s.deleted_at IS NULL
`

type GetStoryByShortCodeRow struct {
	ID           int64
	UserID       int64
	Url          pgtype.Text
	Title        string
	Body         pgtype.Text
	ShortCode    string
	Upvotes      int32
	Downvotes    int32
	CommentCount int32
	CreatedAt    pgtype.Timestamptz
	Username     string
	Domain       pgtype.Text
	Origin       pgtype.Text
}

func (q *Queries) GetStoryByShortCode(ctx context.Context, shortCode string) (GetStoryByShortCodeRow, error) {
	row := q.db.QueryRow(ctx, getStoryByShortCode, shortCode)
	var i GetStoryByShortCodeRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.Body,
		&i.ShortCode,
		&i.Upvotes,
		&i.Downvotes,
		&i.CommentCount,
		&i.CreatedAt,
		&i.Username,
		&i.Domain,
		&i.Origin,
	)
	return i, err
}

const getStoryTags = `-- name: GetStoryTags :many
SELECT t.id, t.tag, t.is_media
FROM taggings AS tg
JOIN tags AS t ON t.id = tg.tag_id
WHERE tg.story_id = $1
ORDER BY t.is_media DESC, t.tag ASC
`

type GetStoryTagsRow struct {
	ID      int64
	Tag     string
	IsMedia bool
}

func (q *Queries) GetStoryTags(ctx context.Context, storyID int64) ([]GetStoryTagsRow, error) {
	rows, err := q.db.Query(ctx, getStoryTags, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoryTagsRow
	for rows.Next() {
		var i GetStoryTagsRow
		if err := rows.Scan(&i.ID, &i.Tag, &i.IsMedia); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryTagsWithMod = `-- name: GetStoryTagsWithMod :many
SELECT t.id, t.tag, t.is_media, t.hotness_mod
FROM taggings AS tg
JOIN tags AS t ON t.id = tg.tag_id
WHERE tg.story_id = $1
ORDER BY t.is_media DESC, t.tag ASC
`

type GetStoryTagsWithModRow struct {
	ID         int64
	Tag        string
	IsMedia    bool
	HotnessMod float64
}

func (q *Queries) GetStoryTagsWithMod(ctx context.Context, storyID int64) ([]GetStoryTagsWithModRow, error) {
	rows, err := q.db.Query(ctx, getStoryTagsWithMod, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoryTagsWithModRow
	for rows.Next() {
		var i GetStoryTagsWithModRow
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.IsMedia,
			&i.HotnessMod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentStories = `-- name: ListRecentStories :many
SELECT
    s.id,
    s.url,
    s.title,
    s.body,
    s.short_code,
    s.upvotes,
    s.downvotes,
    s.comment_count,
    s.created_at,
    u.username,
    d.domain,
    o.origin
FROM stories AS s
JOIN users AS u ON u.id = s.user_id
LEFT JOIN domains AS d ON d.id = s.domain_id
LEFT JOIN origins AS o ON o.id = s.origin_id
WHERE s.deleted_at IS NULL
  AND s.id NOT IN (
    SELECT tg.story_id FROM taggings AS tg
    WHERE tg.tag_id = ANY($1::bigint[])
  )
ORDER BY s.created_at DESC
LIMIT $2
`

type ListRecentStoriesParams struct {
	HiddenTagIds []int64
	StoryLimit   int32
}

type ListRecentStoriesRow struct {
	ID           int64
	Url          pgtype.Text
	Title        string
	Body         pgtype.Text
	ShortCode    string
	Upvotes      int32
	Downvotes    int32
	CommentCount int32
	CreatedAt    pgtype.Timestamptz
	Username     string
	Domain       pgtype.Text
	Origin       pgtype.Text
}

func (q *Queries) ListRecentStories(ctx context.Context, arg ListRecentStoriesParams) ([]ListRecentStoriesRow, error) {
	rows, err := q.db.Query(ctx, listRecentStories, arg.HiddenTagIds, arg.StoryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentStoriesRow
	for rows.Next() {
		var i ListRecentStoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Body,
			&i.ShortCode,
			&i.Upvotes,
			&i.Downvotes,
			&i.CommentCount,
			&i.CreatedAt,
			&i.Username,
			&i.Domain,
			&i.Origin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentStoriesByTag = `-- name: ListRecentStoriesByTag :many
SELECT
    s.id,
    s.url,
    s.title,
    s.body,
    s.short_code,
    s.upvotes,
    s.downvotes,
    s.comment_count,
    s.created_at,
    u.username,
    d.domain,
    o.origin
FROM stories AS s
         JOIN users AS u ON u.id = s.user_id
         LEFT JOIN domains AS d ON d.id = s.domain_id
         LEFT JOIN origins AS o ON o.id = s.origin_id
         JOIN taggings AS tg ON tg.story_id = s.id
WHERE tg.tag_id = $1
  AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
LIMIT $2
`

type ListRecentStoriesByTagParams struct {
	TagID      int64
	StoryLimit int32
}

type ListRecentStoriesByTagRow struct {
	ID           int64
	Url          pgtype.Text
	Title        string
	Body         pgtype.Text
	ShortCode    string
	Upvotes      int32
	Downvotes    int32
	CommentCount int32
	CreatedAt    pgtype.Timestamptz
	Username     string
	Domain       pgtype.Text
	Origin       pgtype.Text
}

func (q *Queries) ListRecentStoriesByTag(ctx context.Context, arg ListRecentStoriesByTagParams) ([]ListRecentStoriesByTagRow, error) {
	rows, err := q.db.Query(ctx, listRecentStoriesByTag, arg.TagID, arg.StoryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentStoriesByTagRow
	for rows.Next() {
		var i ListRecentStoriesByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Body,
			&i.ShortCode,
			&i.Upvotes,
			&i.Downvotes,
			&i.CommentCount,
			&i.CreatedAt,
			&i.Username,
			&i.Domain,
			&i.Origin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoriesByUsername = `-- name: ListStoriesByUsername :many
SELECT
    s.id,
    s.url,
    s.title,
    s.body,
    s.short_code,
    s.upvotes,
    s.downvotes,
    s.comment_count,
    s.created_at,
    u.username,
    d.domain,
    o.origin
FROM stories AS s
JOIN users AS u ON u.id = s.user_id
LEFT JOIN domains AS d ON d.id = s.domain_id
LEFT JOIN origins AS o ON o.id = s.origin_id
WHERE lower(u.username) = lower($1)
  AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
LIMIT $2
`

type ListStoriesByUsernameParams struct {
	Username   string
	StoryLimit int32
}

type ListStoriesByUsernameRow struct {
	ID           int64
	Url          pgtype.Text
	Title        string
	Body         pgtype.Text
	ShortCode    string
	Upvotes      int32
	Downvotes    int32
	CommentCount int32
	CreatedAt    pgtype.Timestamptz
	Username     string
	Domain       pgtype.Text
	Origin       pgtype.Text
}

func (q *Queries) ListStoriesByUsername(ctx context.Context, arg ListStoriesByUsernameParams) ([]ListStoriesByUsernameRow, error) {
	rows, err := q.db.Query(ctx, listStoriesByUsername, arg.Username, arg.StoryLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStoriesByUsernameRow
	for rows.Next() {
		var i ListStoriesByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Body,
			&i.ShortCode,
			&i.Upvotes,
			&i.Downvotes,
			&i.CommentCount,
			&i.CreatedAt,
			&i.Username,
			&i.Domain,
			&i.Origin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateStoryScores = `-- name: RecalculateStoryScores :execrows
UPDATE stories SET
  upvotes = coalesce(v.cnt, 0)::int,
  downvotes = coalesce(hf.cnt, 0)::int
FROM stories s2
LEFT JOIN (SELECT story_id, count(*) AS cnt FROM votes GROUP BY story_id) v ON v.story_id = s2.id
LEFT JOIN (
    SELECT hs.story_id, count(*) AS cnt
    FROM hidden_stories hs
    JOIN story_flags sf ON sf.user_id = hs.user_id AND sf.story_id = hs.story_id
    WHERE NOT EXISTS (
        SELECT 1 FROM comments c
        WHERE c.story_id = hs.story_id AND c.user_id = hs.user_id AND c.deleted_at IS NULL
    )
    GROUP BY hs.story_id
) hf ON hf.story_id = s2.id
WHERE stories.id = s2.id
`

func (q *Queries) RecalculateStoryScores(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, recalculateStoryScores)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateStoryBody = `-- name: UpdateStoryBody :exec
UPDATE stories SET body = $1, updated_at = now() WHERE id = $2
`

type UpdateStoryBodyParams struct {
	Body pgtype.Text
	ID   int64
}

func (q *Queries) UpdateStoryBody(ctx context.Context, arg UpdateStoryBodyParams) error {
	_, err := q.db.Exec(ctx, updateStoryBody, arg.Body, arg.ID)
	return err
}

const updateStoryTitle = `-- name: UpdateStoryTitle :exec
UPDATE stories SET title = $1, updated_at = now() WHERE id = $2
`

type UpdateStoryTitleParams struct {
	Title string
	ID    int64
}

func (q *Queries) UpdateStoryTitle(ctx context.Context, arg UpdateStoryTitleParams) error {
	_, err := q.db.Exec(ctx, updateStoryTitle, arg.Title, arg.ID)
	return err
}

const updateStoryURL = `-- name: UpdateStoryURL :exec
UPDATE stories SET url = $1, normalized_url = $2, domain_id = $3, origin_id = $4, updated_at = now() WHERE id = $5
`

type UpdateStoryURLParams struct {
	Url           pgtype.Text
	NormalizedUrl pgtype.Text
	DomainID      pgtype.Int8
	OriginID      pgtype.Int8
	ID            int64
}

func (q *Queries) UpdateStoryURL(ctx context.Context, arg UpdateStoryURLParams) error {
	_, err := q.db.Exec(ctx, updateStoryURL,
		arg.Url,
		arg.NormalizedUrl,
		arg.DomainID,
		arg.OriginID,
		arg.ID,
	)
	return err
}
