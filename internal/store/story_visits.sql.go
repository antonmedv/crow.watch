// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: story_visits.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUnreadReplies = `-- name: CountUnreadReplies :one
SELECT count(*)
FROM comments AS c
JOIN comments AS parent ON parent.id = c.parent_id
LEFT JOIN story_visits AS sv ON sv.user_id = $1 AND sv.story_id = c.story_id
WHERE parent.user_id = $1
  AND c.user_id != $1
  AND c.deleted_at IS NULL
  AND (sv.last_seen_at IS NULL OR c.created_at > sv.last_seen_at)
`

func (q *Queries) CountUnreadReplies(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadReplies, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStoryVisit = `-- name: GetStoryVisit :one
SELECT last_seen_at
FROM story_visits
WHERE user_id = $1 AND story_id = $2
`

type GetStoryVisitParams struct {
	UserID  int64
	StoryID int64
}

func (q *Queries) GetStoryVisit(ctx context.Context, arg GetStoryVisitParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getStoryVisit, arg.UserID, arg.StoryID)
	var last_seen_at pgtype.Timestamptz
	err := row.Scan(&last_seen_at)
	return last_seen_at, err
}

const listReplies = `-- name: ListReplies :many
SELECT
    c.id AS comment_id,
    c.body,
    c.created_at,
    c.deleted_at,
    u.username AS comment_author,
    s.title AS story_title,
    s.short_code AS story_short_code,
    (sv.last_seen_at IS NULL OR c.created_at > sv.last_seen_at)::bool AS is_unread
FROM comments AS c
JOIN users AS u ON u.id = c.user_id
JOIN comments AS parent ON parent.id = c.parent_id
JOIN stories AS s ON s.id = c.story_id
LEFT JOIN story_visits AS sv ON sv.user_id = $1 AND sv.story_id = c.story_id
WHERE parent.user_id = $1
  AND c.user_id != $1
  AND c.deleted_at IS NULL
ORDER BY c.created_at DESC
LIMIT 50
`

type ListRepliesRow struct {
	CommentID      int64
	Body           string
	CreatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	CommentAuthor  string
	StoryTitle     string
	StoryShortCode string
	IsUnread       bool
}

func (q *Queries) ListReplies(ctx context.Context, userID int64) ([]ListRepliesRow, error) {
	rows, err := q.db.Query(ctx, listReplies, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRepliesRow
	for rows.Next() {
		var i ListRepliesRow
		if err := rows.Scan(
			&i.CommentID,
			&i.Body,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.CommentAuthor,
			&i.StoryTitle,
			&i.StoryShortCode,
			&i.IsUnread,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertStoryVisit = `-- name: UpsertStoryVisit :exec
INSERT INTO story_visits (user_id, story_id, last_seen_at)
VALUES ($1, $2, now())
ON CONFLICT (user_id, story_id) DO UPDATE SET last_seen_at = now()
`

type UpsertStoryVisitParams struct {
	UserID  int64
	StoryID int64
}

func (q *Queries) UpsertStoryVisit(ctx context.Context, arg UpsertStoryVisitParams) error {
	_, err := q.db.Exec(ctx, upsertStoryVisit, arg.UserID, arg.StoryID)
	return err
}
