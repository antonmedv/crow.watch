// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: story_flags.sql

package store

import (
	"context"
)

const createStoryFlag = `-- name: CreateStoryFlag :exec
INSERT INTO story_flags (user_id, story_id, reason)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type CreateStoryFlagParams struct {
	UserID  int64
	StoryID int64
	Reason  string
}

func (q *Queries) CreateStoryFlag(ctx context.Context, arg CreateStoryFlagParams) error {
	_, err := q.db.Exec(ctx, createStoryFlag, arg.UserID, arg.StoryID, arg.Reason)
	return err
}

const deleteStoryFlag = `-- name: DeleteStoryFlag :exec
DELETE FROM story_flags
WHERE story_flags.user_id = $1 AND story_flags.story_id = $2
`

type DeleteStoryFlagParams struct {
	UserID  int64
	StoryID int64
}

func (q *Queries) DeleteStoryFlag(ctx context.Context, arg DeleteStoryFlagParams) error {
	_, err := q.db.Exec(ctx, deleteStoryFlag, arg.UserID, arg.StoryID)
	return err
}

const getStoryFlagCounts = `-- name: GetStoryFlagCounts :many
SELECT reason, count(*)::int AS count
FROM story_flags
WHERE story_id = $1
GROUP BY reason
ORDER BY count DESC
`

type GetStoryFlagCountsRow struct {
	Reason string
	Count  int32
}

func (q *Queries) GetStoryFlagCounts(ctx context.Context, storyID int64) ([]GetStoryFlagCountsRow, error) {
	rows, err := q.db.Query(ctx, getStoryFlagCounts, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoryFlagCountsRow
	for rows.Next() {
		var i GetStoryFlagCountsRow
		if err := rows.Scan(&i.Reason, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryFlags = `-- name: GetUserStoryFlags :many
SELECT story_id
FROM story_flags
WHERE user_id = $1 AND story_id = ANY($2::bigint[])
`

type GetUserStoryFlagsParams struct {
	UserID   int64
	StoryIds []int64
}

func (q *Queries) GetUserStoryFlags(ctx context.Context, arg GetUserStoryFlagsParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUserStoryFlags, arg.UserID, arg.StoryIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var story_id int64
		if err := rows.Scan(&story_id); err != nil {
			return nil, err
		}
		items = append(items, story_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateStoryDownvotes = `-- name: RecalculateStoryDownvotes :exec
UPDATE stories SET downvotes = (
    SELECT count(*)
    FROM hidden_stories hs
    JOIN story_flags sf ON sf.user_id = hs.user_id AND sf.story_id = hs.story_id
    WHERE hs.story_id = $1
      AND NOT EXISTS (
          SELECT 1 FROM comments c
          WHERE c.story_id = $1 AND c.user_id = hs.user_id AND c.deleted_at IS NULL
      )
)
WHERE id = $1
`

// Count users who hid AND flagged this story AND have no comments on it
func (q *Queries) RecalculateStoryDownvotes(ctx context.Context, storyID int64) error {
	_, err := q.db.Exec(ctx, recalculateStoryDownvotes, storyID)
	return err
}
