// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSession = `-- name: CreateSession :exec
INSERT INTO sessions (
    user_id,
    token_hash,
    user_agent,
    ip_address,
    expires_at,
    last_seen_at,
    created_at,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    now(),
    now(),
    now()
)
`

type CreateSessionParams struct {
	UserID    int64
	TokenHash string
	UserAgent string
	IpAddress string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, createSession,
		arg.UserID,
		arg.TokenHash,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at <= now()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteSessionByTokenHash = `-- name: DeleteSessionByTokenHash :exec
DELETE FROM sessions
WHERE token_hash = $1
`

func (q *Queries) DeleteSessionByTokenHash(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, deleteSessionByTokenHash, tokenHash)
	return err
}

const deleteSessionsByUserID = `-- name: DeleteSessionsByUserID :exec
DELETE FROM sessions
WHERE user_id = $1
`

func (q *Queries) DeleteSessionsByUserID(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteSessionsByUserID, userID)
	return err
}

const getSessionUserByTokenHash = `-- name: GetSessionUserByTokenHash :one
SELECT
    s.id AS session_id,
    s.expires_at,
    u.id,
    u.username,
    u.email,
    u.password_digest,
    u.is_moderator,
    u.banned_at,
    u.deleted_at,
    u.inviter_id,
    u.password_reset_token_hash,
    u.password_reset_token_created_at,
    u.email_confirmed_at,
    u.email_confirmation_token_created_at,
    u.unconfirmed_email,
    u.website,
    u.about,
    u.created_at,
    u.updated_at
FROM sessions AS s
JOIN users AS u ON u.id = s.user_id
WHERE s.token_hash = $1
  AND s.expires_at > now()
LIMIT 1
`

type GetSessionUserByTokenHashRow struct {
	SessionID                       int64
	ExpiresAt                       pgtype.Timestamptz
	ID                              int64
	Username                        string
	Email                           string
	PasswordDigest                  string
	IsModerator                     bool
	BannedAt                        pgtype.Timestamptz
	DeletedAt                       pgtype.Timestamptz
	InviterID                       pgtype.Int8
	PasswordResetTokenHash          pgtype.Text
	PasswordResetTokenCreatedAt     pgtype.Timestamptz
	EmailConfirmedAt                pgtype.Timestamptz
	EmailConfirmationTokenCreatedAt pgtype.Timestamptz
	UnconfirmedEmail                pgtype.Text
	Website                         string
	About                           string
	CreatedAt                       pgtype.Timestamptz
	UpdatedAt                       pgtype.Timestamptz
}

func (q *Queries) GetSessionUserByTokenHash(ctx context.Context, tokenHash string) (GetSessionUserByTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getSessionUserByTokenHash, tokenHash)
	var i GetSessionUserByTokenHashRow
	err := row.Scan(
		&i.SessionID,
		&i.ExpiresAt,
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordDigest,
		&i.IsModerator,
		&i.BannedAt,
		&i.DeletedAt,
		&i.InviterID,
		&i.PasswordResetTokenHash,
		&i.PasswordResetTokenCreatedAt,
		&i.EmailConfirmedAt,
		&i.EmailConfirmationTokenCreatedAt,
		&i.UnconfirmedEmail,
		&i.Website,
		&i.About,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const touchSession = `-- name: TouchSession :exec
UPDATE sessions
SET updated_at = now(),
    last_seen_at = now()
WHERE id = $1
`

func (q *Queries) TouchSession(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, touchSession, id)
	return err
}
