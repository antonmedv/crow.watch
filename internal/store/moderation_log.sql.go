// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: moderation_log.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countModerationLog = `-- name: CountModerationLog :one
SELECT count(*) FROM moderation_log
`

func (q *Queries) CountModerationLog(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countModerationLog)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createModerationLog = `-- name: CreateModerationLog :one
INSERT INTO moderation_log (moderator_id, action, target_type, target_id, reason, metadata)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, moderator_id, action, target_type, target_id, reason, metadata, created_at
`

type CreateModerationLogParams struct {
	ModeratorID int64
	Action      string
	TargetType  string
	TargetID    int64
	Reason      string
	Metadata    []byte
}

func (q *Queries) CreateModerationLog(ctx context.Context, arg CreateModerationLogParams) (ModerationLog, error) {
	row := q.db.QueryRow(ctx, createModerationLog,
		arg.ModeratorID,
		arg.Action,
		arg.TargetType,
		arg.TargetID,
		arg.Reason,
		arg.Metadata,
	)
	var i ModerationLog
	err := row.Scan(
		&i.ID,
		&i.ModeratorID,
		&i.Action,
		&i.TargetType,
		&i.TargetID,
		&i.Reason,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listModerationLog = `-- name: ListModerationLog :many
SELECT ml.id, ml.moderator_id, ml.action, ml.target_type, ml.target_id, ml.reason, ml.metadata, ml.created_at, u.username AS moderator_username
FROM moderation_log ml
JOIN users u ON u.id = ml.moderator_id
ORDER BY ml.created_at DESC
LIMIT $2 OFFSET $1
`

type ListModerationLogParams struct {
	LogOffset int32
	LogLimit  int32
}

type ListModerationLogRow struct {
	ID                int64
	ModeratorID       int64
	Action            string
	TargetType        string
	TargetID          int64
	Reason            string
	Metadata          []byte
	CreatedAt         pgtype.Timestamptz
	ModeratorUsername string
}

func (q *Queries) ListModerationLog(ctx context.Context, arg ListModerationLogParams) ([]ListModerationLogRow, error) {
	rows, err := q.db.Query(ctx, listModerationLog, arg.LogOffset, arg.LogLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListModerationLogRow
	for rows.Next() {
		var i ListModerationLogRow
		if err := rows.Scan(
			&i.ID,
			&i.ModeratorID,
			&i.Action,
			&i.TargetType,
			&i.TargetID,
			&i.Reason,
			&i.Metadata,
			&i.CreatedAt,
			&i.ModeratorUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
